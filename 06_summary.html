<h2>단원 마무리</h2>

<p>1. classList</p>
태그.classList 객체를 통해 태그에 붙은 클래스를 조작 가능
해당 클래스가 존재하는지 확인하려면 contains 메서드를 사용함

<script>

    태그.classList.contains('클래스');

</script>

해당 클래스를 추가하거나 수정 및 제거하려면 각각 add와 replace, remove 메서드를 사용

<script>

    태그.classList.add('클래스'); //추가
    태그.classList.replace('기존클래스', '수정클래스'); //수정
    태그.classList.remove('클래스'); //제거

</script>


<p>2. Date</p>
현재 시각을 알고 싶을 때

<script>

    new Date();

</script>

시각을 직접 지정하고 싶을 때는 인수로 연, 월, 일, 시, 분, 초를 넣음
월은 0부터 시작

<script>

    new Date(2021, 2, 31);
    //Wed Mar 31 2021 00:00:00 GMT+0900 (대한민국 표준시)

    new Date(2021, 2, 31, 18, 30, 5);
    //Wed Mar 31 2021 18:30:05 GMT+0900 (대한민국 표준시)

</script>

두 값을 빼면 시간 차이가 밀리초 단위로 나옴


<p>3. 배열.reduce</p>
reduce는 배열에 있는 반복 메서드의 일종으로 배열의 요소들을 하나의 값으로 합침

<script>

    배열.reduce((누적값, 현잿값) => {
        return 새로운누적값;
    }, 초깃값);

</script>

함수에서 반환되는 값은 다음 번 누적값이 되고, 마지막으로 반환되는 값이 reduce 메서드의 결괏값이 됨
초깃값을 지정하지 않으면 배열의 첫 번째 요소가 초깃값이 됨

<script>
    //초깃값이 있을 때

    [1, 2, 3, 4, 5].reduce((a, c) => {
        return a + c;
    }, 0); //초깃값 0이 첫번째 누적값(a)이 되고, 배열의 첫 번째 요소가 현잿값(c)이 됨

/*
    a + c를 한 반환값은 다음 번 누적값이 됨. 이런 식으로 배열의 마지막 요소까지 함수가 반복해서 실행됨
    
    <초깃값이 있는 reduce 계산표>
    a(누적값)     0       1       3       6       10     
    c(현잿값)     1       2       3       4       5
    a+c(반환값)   1       3       6       10      15

    마지막으로 반환되는 값인 15가 reduce 메서드의 결괏값이 됨
    함수는 모든 배열의 요소를 한 번씩 사용하고 있음 -> reduce 메서드도 일종의 반복문 역할을 함
*/
</script>

<script>
    //초깃값이 없을 때

    [1, 2, 3, 4, 5].reduce((a, c) => {
        return a + c;
    }); //첫번째 요소인 1이 누적값(a)이 되고, 현잿값(c)는 2가 됨


/*
    첫번째 요소인 1이 초깃값이 되고, 초깃값이 첫 번째 누적값으로 들어감 / 두번째부터 reduce 적용
    -> a = 1, c = 2 상태로 함수 시작
    반환값인 3은 다음 번의 누적값이 됨

    <초깃값이 없는 reduce 계산표>
    a(누적값)     1       3       6       10          
    c(현잿값)     2       3       4       5      
    a+c(반환값)   3       6       10      15
*/

</script>