<h2>단원 마무리</h2>

<p>1. 호출 스택</p>
동기 함수만 있을 때는 호출 스택만 생각하면 됨
함수가 호출될 대 호출 스택에 들어가고, 실행이 완료되면 호출 스택에서 빠져나감
기존 함수의 실행이 완료되지 않았는데 다른 함수가 호출되면 새로 호출된 함수는 기존 함수 위에 쌓임

처음 파일을 실행할 때는 anonymous(크롬 브라우저 기준)라는 익명 함수가 실행됨
<script>
    //anonymous 함수의 존재 파악
    function a() {
        b();
    }

    function b() {
        console.trace(); //함수의 호출 스택을 보여주는 메서드
    }
    a();

    //결과 실행 순서: anonymous -> a -> b

</script>


<p>2. 이벤트 루프</p>
비동기 함수가 실행될 때는 호출 스택 뿐만 아니라 이벤트 루프까지 동원해 실행 순서를 파악해야 함
타이머나 이벤트 리스너 같은 비동기 함수들은 콜백 함수를 백그라운드에서 태스크 류로 보냄
이벤트 루프는 호출 스택이 비어 있으면 태스크 큐에서 함수를 하나씩 꺼내 호출 스택으로 보내 실행함
반대로 말하면 호출 스택이 비어있지 않으면 태스크 큐에 있는 함수는 실행되지 않음


<p>코드의 실행 순서</p>
코드 실행순서 파악: 호출 스택(call stack) / 이벤트 루프(event loop)  개념

호출 스택: 동기 코드 담당
이벤트 루프: 비동기 코드 담당

비동기 코드 실행 -> 백그라운드(background), 태스크 큐(task queue) 

백그라운드: 타이머를 처리하고 이벤트 리스너를 저장하는 공간
setTimeout 같은 함수가 실행되면 백그라운드에서 시간을 재고 시간이 되면 setTimeout의 콜백 함수를
태스크 큐로 보냄
또한, addEventListener로 추가한 이벤트를 저장했다가 이벤트가 발생하면 콜백 함수를 태스크 큐로 보냄
실행될 콜백 함수들이 태스크 큐로 들어감(O) / 백그라운드에서 코드를 실행하는 것(X)

태스크 큐: 실행돼야 할 콜백 함수들이 줄을 서서 대기하고 있는 공간 (queue: 줄)
태스크 큐에 먼저 들어온 함수부터 실행 됨, 그러나 태스크 큐도 함수를 직접 실행하지 않음
함수는 모두 호출 스택에서만 실행 됨 / 호출 스택에 들어온 함수가 호출(실행)되는 것

이벤트 루프: 태스크 큐에서 호출 스택으로 함수를 이동시키는 존재
호출 스택이 비어 있으면 이벤트 루프는 태스크 큐에서 함수를 하나씩 꺼내(들어온 순서대로 꺼냄) 호출 스택으로 옮김
호출 스택으로 이동한 함수는 그제야 실행 됨
실행이 완료된 함수는 호출 스택에서 빠져나가게 되고, 호출 스택이 비면 이벤트 루프는 태스크 큐에 있는
다음 함수를 호출 스택으로 옮김

변수나 함수의 선언 -> 호출 스택과 이벤트 루프에 영향(X)
선언: 스코프의 영역
호출 스택, 이벤트 루프: 함수 호출 관련 

자바스크립트 엔진은 자바스크립트 소스 코드가 처음 실행되는 순간에도 하나의 함수가 실행되고 있음
-> anonymous 함수(크롬 브라우저)


<p>예제에서의 이벤트 호출 순서</p>
함수가 호출되는 첫 번째 순간: startGame();

1) 소스코드가 실행될 때 anonymous 함수가 먼저 호출 스택에 들어가 있고, 
startGame 함수가 호출되면 anonymous 함수 위에 위치함
기존 함수가 끝나기 전에 새 함수가 실행되면 새 함수는 기존 함수 위에 위치함

2) startGame이 호출되면 startGame 안에 들어 있는 코드들이 위에서 아래의 순서로 실행됨
shuffle 함수가 실행되고, 카드를 섞은 뒤 shuffle 함수가 종료됨
shuffle 함수는 startGame 위에 위치했다가 완료되면 사라짐

3) shuffle 후에는 createCard 함수가 반복문에 의해 12번 호출 스택에 들어왔다 나감(startGame 위에서)
addEventListener -> 이벤트 리스너는 등록하는 순간 [백그라운드]에 저장됨
addEventListener도 반복문에 의해 12번 호출되므로 백그라운드에는 12개의 이벤트 리스너가 등록됨

4) 초반에 카드를 공개하는 코드가 실행됨
forEach 메서드가 실행되고, 여기서 setTimeout이 처음 나옴
첫 번째 카드는 1초 후에, 두 번째 카드는 1.1초 후에, 마지막 카드는 2.1초 후에 뒤집히도록 타이머 설정함
타이머들도 호출되는 순간 백그라운드에 등록됨(but 실행X)
12개의 타이머가 백그라운드에 등록된 후에는 5초 뒤에 카드를 감추는 setTimeout이 실행됨
이 타이머도 백그라운드에 등록됨
<!-- startGame 함수 끝 -->

5) startGame 함수 끝
타이머들이 백그라운드에 남아 있지만, 호출 스택에서는 동기 코드만 따져야 함
동기 코드가 모두 끝났으니 호출 스택에서 지워지고, 전체 소스 코드의 동기 부분도 끝났으니
anonymous 함수도 호출 스택에서 지워짐
[호출 스택은 이제 비어 있는 상태]

6) 백그라운드에는 1초부터 2.1초까지의 타이머 12개와 5초 타이머 1개가 존재함
백그라운드는 시간을 재서 1초가 지나면 타이머의 콜백 함수를 태스크 큐로 보냄
태스크 큐로 콜백함수를 보낸 타이머는 백그라운드에서 제거됨

7) 이벤트 루프는 호출 스택이 비어 있으면 태스크 큐에서 함수들을 하나씩 끌어 올림
가장 먼저 1초 타이머의 콜백 함수가 호출 스택으로 올라가면서 카드에 flipped 클래스를 추가하고,
콜백 함수가 종료되면 호출 스택에서 빠져나감

8) 1.1초 타이머의 콜백 함수가 호출 스택으로 올라갔다가 빠져나가고, 
그 다음에는 1.2초 타이머의 콜백 함수가 올라갔다가 나감
다만, 시간이 되었다고 전부 호출 스택으로 올라가는 것이 아니라 이전 함수가 끝나서 호출 스택이 비어 있어야만
태스크 큐의 함수가 호출 스택으로 올라감

9) 이렇게 순서대로 호출 스택으로 이동해 마지막 5초 타이머의 콜백 함수까지 호출 스택으로 올라갔다 나감
그러고 나면 호출 스택뿐만 아니라 태스크 큐까지 비게 됨 -> 순서도의 [대기 상태]
이때 백그라운드는 비어 있지 않아도 됨

<!--사용자 발생 이벤트 발생-->
10) 이제는 사용자가 발생시키는 이벤트를 기다리면 됨
백그라운드에는 12개의 이벤트 리스너가 존재하는데, 
이 중에서 2, 5, 8, 9번 카드를 클릭했다고 가정 (네 카드는 모두 색이 다른 카드)
클릭 이벤트가 4번 발생하므로 백그라운드에서 클릭 이벤트의 콜백 함수 네 개를 태스크 큐로 보냄
태스크 큐에는 실행된 순서로 콜백 함수 네 개가 줄을 서서 대기하게 됨

11) 이벤트 루프는 호출 스택이 비어 있으므로 콜백 함수를 하나씩 불러 실행함
2번 카드의 클릭 콜백 함수가 실행되고, 이 카드는 clicked 배열에 추가된 뒤 함수가 끝나 호출 스택에서
빠져나감

12) 5번 카드의 클릭 콜백 함수가 실행될 때는 clicked 배열에 두 카드가 추가됨
두 카드의 색이 다르니 setTimeout이 실행되고, 0.5초 타이머가 백그라운드에 생성됨

<!-- 버그 발생 원인 -->
태스크 큐에 들어온 순서대로 호출 스택으로 가다보니 0.5초 타이머의 콜백 함수보다
8번 카드의 클릭 콜백 함수가 먼저 실행됨
다음으로 8번 카드의 클릭 콜백 함수가 실행되면 clicked 배열에 [2, 5, 8], 이렇게 세 개 카드가
들어 있게 됨
clicked 배열에는 최대 2개 카드만 존재한다고 예상했으나(2개가 되면 같은 색이든 다른 색이든 clicked가 비워져야 하므로)
clicked 배열에 3개의 카드가 들어 있는 상황 발생

여기서 9번 카드의 클릭 콜백함수까지 실행되면 clicked 배열에는 [2, 5, 8, 9]가 들어있게 됨
9번 카드의 클릭 콜백 함수가 끝나고 호출 스택이 비어 있으니 0.5초 타이머의 콜백 함수 세개가 연이어 실행되는데,
여기서 clicked[0]과 clicked[1]인 2번과 5번 카드를 뒷면으로 뒤집고 clicked 배열을 []로 초기화함
clicked[2], clicked[3]인 8번과 9번 카드는 뒤집히지 않은 채(앞면인 채) 남아 있게 됨

<!-- 해결 방법 -->
문제: 카드를 뒷면으로 뒤집고 clicked를 []로 초기화하기 전에 8번, 9번 카드의 클릭 이벤트 콜백 함수가 실행되는 것
-> 코드가 실행되는 순서는 정해져 있으므로 실행 자체를 막을 순 없음,
   따라서 실행되더라도 아무 일도 하지 않게 만들면 됨
-> 카드가 2장이 될 때 clickable을 false로 만들어서 세 번째 카드부터는 클릭해도 아무일X고 끝냄