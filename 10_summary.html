<h2>단원 마무리</h2>

<p>1. contextmenu 이벤트</p>
지금까지 마우스 클릭 이벤트는 모두 좌클릭이었음 / 마우스 우클릭 이벤트는 따로 존재
좌클릭 이벤트: click / 우클릭 이벤트: contextmenu
contextmenu 이벤트: 기본적으로 브라우저 메뉴를 띄우므로 이를 막으려면 event.preventDefault 메서드 호출


<p>2. 옵셔널 체이닝</p>
[?.] : 옵셔널 체이닝(optional chaining) 문법
앞에 있는 것이 참(truthy)인 값이면 뒤 코드를 실행하고, 거짓(falsy)인 값이면 코드를 모두 undefined로 만듦

<script>
    const obj = undefined;
    const arr = undefined;
    const func = undefined;
    obj?.b; //undefined;
    arr?.[0]; //undefined;
    func?.(); //undefined;
</script>

객체나 배열 뿐만 아니라 함수에도 옵셔널 체이닝을 적용 가능
속성에 접근하거나 호출하려는 것이 거짓인 값인지 아닌지 의심될 때 옵셔널 체이닝 적용


<p>3. 재귀 함수</p>
재귀함수(recursive function): 어떤 함수의 내부에서 자기 자신을 다시 호출하는 함수

<script>
    let i = 0;

    function recurse() {
        i++;
        recurse();
    }

</script>

재귀 함수를 사용할 때 호출 스택의 최대 크기를 초과하는 경우가 빈번하게 발생함
이때 Maximum call stack size exceeded 오류가 발생하는데, 
setTimeout과 같은 비동기 함수를 사용해 해결 가능
재귀 함수를 사용할 때는 연산량이 많으면 브라우저가 느려지는 현상이 발생하므로
연산량을 최소화할 수 있게 코드를 작성


<p>&& 연산자</p>
if문을 줄이기 위해 사용
앞의 식이 참이면 뒤의 식을 실행하고, 앞의 식이 거짓이면 뒤의 식을 실행하지 않음

<script>

mines.includes(data[rowIndex - 1]?.[cellIndex - 1]) && i++;

if(mines.includes(data[rowIndex - 1]?.[cellIndex - 1])) {
    i++;
} //둘 다 같은 식

</script>